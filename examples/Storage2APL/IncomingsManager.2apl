include: person.2apl;


beliefs:
	start(0,0).
	state(waiting).
	worker(rider1, free).
	worker(rider2, free).
	clean_ig(blockworld) :- not bomb(1, 1).


beliefupdates:  	
  	{ worker(R, free) }		AssignRider(R)			{ not worker(R, free), worker(R, on_task) }
  	{ worker(R, on_task) }	FreeRider(R)			{ not worker(R, on_task), worker(R, free) }
  	
  	{ state(waiting) } 		LookingForShelfStatus() { not state(waiting), state(assignShelf) }
  	{ state(assignShelf) }	AssignRiderStatus() 	{ not state(assignShelf), state(assignRider) }
  	{ state(assignRider) }	WaitForPickupStatus()	{ not state(assignRider), state(waitForPickup) }
  	{ state(waitForPickup)}	WaitingStatus()			{ not state(waitForPickup), state(waiting) }


goals:
	clean_ig(blockworld).


plans:
  B(start(X,Y));
  @blockworld( enter( X, Y, blue ), _ );
  @blockworld( senseBombs(), BOMBS );
  if B(BOMBS = [[default, 1, 1] | REST]) then
  {
  	+ bomb(1, 1);
  }
  

pgrules:
	clean_ig( blockworld ) <- state(waiting) and worker(RIDER, free) |
	{
  		send(shelves, request, stupid(RIDER));
  		LookingForShelfStatus();
  	}
  	
  	clean_ig( blockworld ) <- state(assignRider) and bomb(Xb, Yb) and target_shelf(Xs, Ys) and worker(RIDER, free) |
  	{
		send(RIDER, inform, stockProduct(Xb, Yb, Xs, Ys));
		- target_shelf(Xs, Ys);
		AssignRider(RIDER);
		send(om, inform, assignRider(RIDER));
		WaitForPickupStatus();
  	}


pcrules:
	event(bombAt(1, 1), blockworld) <- true |
	{
		+ bomb(1, 1);
		adoptz(clean_ig(blockworld));
	}
	
	message(shelves, inform, La, On, shelf(X, Y)) <- true | {
		+ target_shelf(X, Y);
		AssignRiderStatus();
	}
	
	message(RIDER, inform, La, On, took_over(X, Y)) <- true | {
		- bomb(X, Y);
		WaitingStatus();
	}
	
	message(RIDER, inform, La, On, done(Xb, Yb, Xs, Ys)) <- true | {
		FreeRider(RIDER);
		send(shelves, inform, full(Xs, Ys));
		send(om, inform, freeRider(RIDER));
	}
	
	message(om, inform, La, On, freeRider(RIDER)) <- true |
	{
		FreeRider(RIDER);
	}
	
	message(om, inform, La, On, assignRider(RIDER)) <- true |
	{
		AssignRider(RIDER);
	}