include: person.2apl;

beliefs:
	start(15,15).
	state(waiting).
	worker(rider1, free).
	worker(rider2, free).
	clean_og(blockworld) :- not trap(14, 14).


beliefupdates:  	
  	{ worker(R, free) }		AssignRider(R)			{ not worker(R, free), worker(R, on_task) }
  	{ worker(R, on_task) }	FreeRider(R)			{ not worker(R, on_task), worker(R, free) }
  	
  	{ state(waiting) } 		LookingForShelfStatus() { not state(waiting), state(freeShelf) }
  	{ state(freeShelf) }	AssignRiderStatus() 	{ not state(freeShelf), state(assignRider) }
  	{ state(assignRider) }	WaitForDeliverStatus()	{ not state(assignRider), state(waitForDeliver) }
  	{ state(waitForDeliver)}	WaitingStatus()		{ not state(waitForPickup), state(waiting) }


goals:
	clean_og(blockworld).


plans:
  B(start(X,Y));
  @blockworld( enter( X, Y, green ), _ );
  @blockworld( senseTraps(), TRAPS );
  if B(TRAPS = [[default, 14, 14] | REST]) then
  {
  	+ trap(14, 14);
  }
  

pgrules:
	clean_og( blockworld ) <- state(waiting) and worker(RIDER, free) |
	{
  		send(shelves, request, stupid(RIDER));
  		LookingForShelfStatus();
  	}
  	
  	clean_og( blockworld ) <- state(assignRider) and trap(Xt, Yt) and target_shelf(Xs, Ys) and worker(RIDER, free) |
  	{
		send(RIDER, inform, takeProduct(Xs, Ys, Xt, Yt));
		- target_shelf(Xs, Ys);
		AssignRider(RIDER);
		send(im, inform, assignRider(RIDER));
		WaitForDeliverStatus();
  	}


pcrules:
	event(trapAt(14, 14), blockworld) <- true |
	{
		+ trap(14, 14);
		adoptz(clean_og(blockworld));
	}
	
	message(shelves, inform, La, On, shelf(X, Y)) <- true | {
		+ target_shelf(X, Y);
		AssignRiderStatus();
	}
	
	message(RIDER, inform, La, On, done(Xs, Ys, Xt, Yt)) <- true | {
		FreeRider(RIDER);
		send(im, inform, freeRider(RIDER));
		- trap(Xt, Yt);
		WaitingStatus();
	}
	
	message(im, inform, La, On, freeRider(RIDER)) <- true |
	{
		FreeRider(RIDER);
	}
	
	message(im, inform, La, On, assignRider(RIDER)) <- true |
	{
		AssignRider(RIDER);
	}
	
	
	
	
	
	